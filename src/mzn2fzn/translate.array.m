%-----------------------------------------------------------------------------%
% vim: ts=4 sw=4 et ft=mercury
%-----------------------------------------------------------------------------%
% Copyright (C) 2011 The University of Melbourne and NICTA.
% See the file COPYING for license information.
%-----------------------------------------------------------------------------%
%
% Author: zs.
%
%-----------------------------------------------------------------------------%

:- module translate.array.
:- interface.

:- import_module tfzn_ast.
:- import_module tmzn_ast.
:- import_module translate.info.

:- import_module list.

    % Translate an integer array access from typed MiniZinc to typed FlatZinc
    % in the given context, and return the constraints generated by the
    % translation.
    %
:- pred translate_int_array_access(ilhs::in, src_pos::in,
    tmzn_int_array_expr::in, list(tmzn_int_expr)::in,
    tfzn_int_term::out, tfzn_constraint_set::out,
    tr_info::in, tr_info::out) is det.

    % Translate a float access from typed MiniZinc to typed FlatZinc
    % in the given context, and return the constraints generated by the
    % translation.
    %
:- pred translate_float_array_access(ilhs::in, src_pos::in,
    tmzn_float_array_expr::in, list(tmzn_int_expr)::in,
    tfzn_float_term::out, tfzn_constraint_set::out,
    tr_info::in, tr_info::out) is det.

%-----------------------------------------------------------------------------%

:- implementation.

:- import_module bounds.
:- import_module error_util.
:- import_module mzn_ops.
:- import_module translate.bool.
:- import_module translate.int.
:- import_module translate.vars.
:- import_module types.

:- import_module assoc_list.
:- import_module bool.
:- import_module int.
:- import_module map.
:- import_module maybe.
:- import_module pair.
:- import_module require.
:- import_module set.
:- import_module set_tree234.

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

translate_int_array_access(ILHS, TopSrcPos, TMznIntArrayExpr, IndexExprs,
        ElementTerm, Constraints, !Info) :-
    % XXX flatten.array.m says these translations should have the just_domain
    % annotation in effect.
    list.map2_foldl(translate_int_expr_to_tfzn_term(ILHS),
        IndexExprs, IndexTerms, IndexTermConstraintSets, !Info),
    (
        TMznIntArrayExpr = tmzn_int_array_expr_var(ArraySrcPos,
            TMznIntArrayVar),
        (
            TMznIntArrayVar = tmzn_int_array_var_named(IntArrayVarName)
        ;
            TMznIntArrayVar = tmzn_int_array_var_anon,
            add_nyi_error_info($pred, phase_constraint, ArraySrcPos,
                "tmzn_int_array_var_anon", !Info),
            IntArrayVarName = "dummy"
        ),
        TFznIntArrayVar = tfzn_int_array_var_named(IntArrayVarName),
        TFznIntArrayTerm = tfzn_int_array_term_var(TFznIntArrayVar),
        tr_info_get_var_info_maps(!.Info, VarInfoMaps),
        vim_get_int_array_map(VarInfoMaps, IntArrayMap),
        map.lookup(IntArrayMap, TFznIntArrayVar, VarInfo),
        VarInst = VarInfo ^ viia_inst,
        ElementBounds = VarInfo ^ viia_bounds,
        IndexRanges = VarInfo ^ viia_index_ranges
    ;
        ( TMznIntArrayExpr = tmzn_int_array_expr_consts(ArraySrcPos, _, _)
        ; TMznIntArrayExpr = tmzn_int_array_expr_vars(ArraySrcPos, _, _)
        ; TMznIntArrayExpr = tmzn_int_array_expr_exprs(ArraySrcPos, _, _)
        ; TMznIntArrayExpr = tmzn_int_array_expr_comprehension(ArraySrcPos,
            _, _, _)
        ; TMznIntArrayExpr = tmzn_int_array_expr_from_set(ArraySrcPos, _)
        ),
        add_nyi_error_info($pred, phase_constraint, ArraySrcPos,
            "array expr form", !Info),
        TFznIntArrayVar = tfzn_int_array_var_named("dummy"),
        TFznIntArrayTerm = tfzn_int_array_term_var(TFznIntArrayVar),
        VarInst = var_is_par,
        ElementBounds =
            int_bounds_range(int_minus_infinity, int_plus_infinity),
        IndexRanges = []
    ),
    (
        VarInst = var_is_par,
        Op = array_int_element
    ;
        VarInst = var_is_var,
        Op = array_var_int_element
    ),
    assoc_list.from_corresponding_lists(IndexRanges, IndexTerms,
        IndexRangesTerms),
    check_index_values_and_generate_offset(ILHS, IndexRangesTerms,
        1, _Size, OffsetTerm0, CheckConstraints, OffsetConstraints0,
        LinearSum, Const, BadIndexes, !Info),
    ( if
        LinearSum = [1 - OneVar],
        Const = 0
    then
        OffsetTerm = tfzn_int_term_var(OneVar),
        OffsetConstraints = no_tfzn_constraints
    else
        OffsetTerm = OffsetTerm0,
        OffsetConstraints = OffsetConstraints0
    ),
    (
        BadIndexes = [],
        (
            ILHS = ilhs_true,
            HalfReification = hr_not_reified
        ;
            ILHS = ilhs_var(ILHSVar),
            HalfReification = hr_half_reified(ILHSVar)
        ;
            ILHS = ilhs_reif(_),
            HalfReification = hr_not_reified
            % This implements the strict semantics.
        ),
        ElementVarInfo = var_info_int(var_is_var, var_is_not_output,
            ElementBounds, no),
        add_tmp_var_int(ElementVarInfo, ElementVar, !Info),
        ElementTerm = tfzn_int_term_var(ElementVar),
        ElementConstraint = tfzn_constr_array_int_element(Op,
            OffsetTerm, TFznIntArrayTerm, ElementTerm,
            HalfReification),
        ElementAnn = constr_ann_defines_var(tfzn_def_int_var(ElementVar)),
        ElementAnns = set.make_singleton_set(ElementAnn),
        ElementConstraintItem =
            tfzn_item_constraint(ElementConstraint, ElementAnns),

        Constraints =
            condense_tfzn_constraint_sets(IndexTermConstraintSets) ++
            CheckConstraints ++ OffsetConstraints ++
            one_tfzn_constraint(ElementConstraintItem)
    ;
        BadIndexes = [_ | _],
        add_user_error_info($pred, phase_constraint, TopSrcPos,
            "some index is out of range", !Info),
        ElementTerm = tfzn_int_term_const(0),
        Constraints = no_tfzn_constraints
    ).

translate_float_array_access(ILHS, TopSrcPos, TMznFloatArrayExpr, IndexExprs,
        ElementTerm, Constraints, !Info) :-
    % XXX flatten.array.m says these translations should have the just_domain
    % annotation in effect.
    list.map2_foldl(translate_int_expr_to_tfzn_term(ILHS),
        IndexExprs, IndexTerms, IndexTermConstraintSets, !Info),
    (
        TMznFloatArrayExpr = tmzn_float_array_expr_var(ArraySrcPos,
            TMznFloatArrayVar),
        (
            TMznFloatArrayVar = tmzn_float_array_var_named(FloatArrayVarName)
        ;
            TMznFloatArrayVar = tmzn_float_array_var_anon,
            add_nyi_error_info($pred, phase_constraint, ArraySrcPos,
                "tmzn_float_array_var_anon", !Info),
            FloatArrayVarName = "dummy"
        ),
        TFznFloatArrayVar = tfzn_float_array_var_named(FloatArrayVarName),
        TFznFloatArrayTerm = tfzn_float_array_term_var(TFznFloatArrayVar),
        tr_info_get_var_info_maps(!.Info, VarInfoMaps),
        vim_get_float_array_map(VarInfoMaps, FloatArrayMap),
        map.lookup(FloatArrayMap, TFznFloatArrayVar, VarInfo),
        VarInst = VarInfo ^ vifa_inst,
        ElementBounds = VarInfo ^ vifa_bounds,
        IndexRanges = VarInfo ^ vifa_index_ranges
    ;
        ( TMznFloatArrayExpr = tmzn_float_array_expr_consts(ArraySrcPos, _, _)
        ; TMznFloatArrayExpr = tmzn_float_array_expr_vars(ArraySrcPos, _, _)
        ; TMznFloatArrayExpr = tmzn_float_array_expr_exprs(ArraySrcPos, _, _)
        ; TMznFloatArrayExpr = tmzn_float_array_expr_comprehension(ArraySrcPos,
            _,_,_)
        ),
        add_nyi_error_info($pred, phase_constraint, ArraySrcPos,
            "array expr form", !Info),
        TFznFloatArrayVar = tfzn_float_array_var_named("dummy"),
        TFznFloatArrayTerm = tfzn_float_array_term_var(TFznFloatArrayVar),
        VarInst = var_is_par,
        ElementBounds =
            float_bounds_range(float_minus_infinity, float_plus_infinity),
        IndexRanges = []
    ),
    (
        VarInst = var_is_par,
        Op = array_float_element
    ;
        VarInst = var_is_var,
        Op = array_var_float_element
    ),
    assoc_list.from_corresponding_lists(IndexRanges, IndexTerms,
        IndexRangesTerms),
    check_index_values_and_generate_offset(ILHS, IndexRangesTerms,
        1, _Size, OffsetTerm0, CheckConstraints, OffsetConstraints0,
        LinearSum, Const, BadIndexes, !Info),
    ( if
        LinearSum = [1 - OneVar],
        Const = 0
    then
        OffsetTerm = tfzn_int_term_var(OneVar),
        OffsetConstraints = no_tfzn_constraints
    else
        OffsetTerm = OffsetTerm0,
        OffsetConstraints = OffsetConstraints0
    ),
    (
        BadIndexes = [],
        (
            ILHS = ilhs_true,
            HalfReification = hr_not_reified
        ;
            ILHS = ilhs_var(ILHSVar),
            HalfReification = hr_half_reified(ILHSVar)
        ;
            ILHS = ilhs_reif(_),
            HalfReification = hr_not_reified
            % This implements the strict semantics.
        ),
        ElementVarInfo = var_info_float(var_is_var, var_is_not_output,
            ElementBounds, no),
        add_tmp_var_float(ElementVarInfo, ElementVar, !Info),
        ElementTerm = tfzn_float_term_var(ElementVar),
        ElementConstraint = tfzn_constr_array_float_element(Op,
            OffsetTerm, TFznFloatArrayTerm, ElementTerm,
            HalfReification),
        ElementAnn = constr_ann_defines_var(tfzn_def_float_var(ElementVar)),
        ElementAnns = set.make_singleton_set(ElementAnn),
        ElementConstraintItem =
            tfzn_item_constraint(ElementConstraint, ElementAnns),

        Constraints =
            condense_tfzn_constraint_sets(IndexTermConstraintSets) ++
            CheckConstraints ++ OffsetConstraints ++
            one_tfzn_constraint(ElementConstraintItem)
    ;
        BadIndexes = [_ | _],
        % XXX Context
        % XXX instead of aborting, just record an error message in !Info
        add_user_error_info($pred, phase_constraint, TopSrcPos,
            "some index is out of range", !Info),
        ElementTerm = tfzn_float_term_const(0.0),
        Constraints = no_tfzn_constraints
    ).

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

    % Given a list of index ranges [{LB1, UB1}, {LB2, UB2}, {LB3, UB3}]
    % and a list of index exprs [A1, A2, A3] we want to impose the following
    % constraints:
    %   LB1 <= A1 <= UB1
    %   LB2 <= A2 <= UB2
    %   LB3 <= A3 <= UB3
    % and compute OffsetTerm as the corresponding 1D index:
    %   (A1 - LB1) * ((1 + UB2 - LB2) * (1 + UB3 - LB3) * 1) +
    %   (A2 - LB2) *                   ((1 + UB3 - LB3) * 1) +
    %   (A3 - LB3) *                                     (1) +
    %   1
    %
    % We also return LinearSum and Const, which provide an alternate way to
    % compute the offset using an int_lin_eq constraints. Our caller can pick
    % one or the other.
    %
:- pred check_index_values_and_generate_offset(ilhs::in,
    assoc_list(index_range, tfzn_int_term)::in,
    int::in, int::out, tfzn_int_term::out,
    tfzn_constraint_set::out, tfzn_constraint_set::out,
    assoc_list(int, tfzn_int_var)::out, int::out, list(int)::out,
    tr_info::in, tr_info::out) is det.

check_index_values_and_generate_offset(_ILHS, [], _IndexNo,
        Size, OffsetTerm, CheckConstraints, OffsetConstraints,
        !:LinearSum, !:Const, !:BadIndexes, !Info) :-
    Size = 1,
    OffsetTerm = tfzn_int_term_const(1),
    CheckConstraints = no_tfzn_constraints,
    OffsetConstraints = no_tfzn_constraints,
    !:LinearSum = [],
    !:Const = 1,
    !:BadIndexes = [].
check_index_values_and_generate_offset(ILHS, [Head | Tail], IndexNo,
        Size, OffsetTerm, !:CheckConstraints, !:OffsetConstraints,
        !:LinearSum, !:Const, !:BadIndexes, !Info) :-
    check_index_values_and_generate_offset(ILHS, Tail, IndexNo + 1,
        TailSize, TailOffsetTerm, !:CheckConstraints, !:OffsetConstraints,
        !:LinearSum, !:Const, !:BadIndexes, !Info),
    Head = IndexRange - IndexTerm,
    (
        IndexRange = index_range(LB, UB)
    ;
        IndexRange = index_implicit,
        unexpected($pred, "implicit index")
    ),
    Size = (1 + UB - LB) * TailSize,
    int_bounds_range(IndexLB, IndexUB) =
        find_int_term_bounds(!.Info, IndexTerm),
    ( if ( UB < IndexLB ; IndexUB < LB ) then
        % IndexTerm is necessarily out of range.
        !:BadIndexes = [IndexNo | !.BadIndexes],
        % This is a bust, so just return dummy values.
        OffsetTerm = TailOffsetTerm
    else
        (
            IndexTerm = tfzn_int_term_const(_)
            % We have already seen above that this value is in range;
            % we don't need runtime checks on this index.
        ;
            IndexTerm = tfzn_int_term_var(IndexVar),
            % XXX Reification
            Reification = ilhs_to_tfzn_reification(ILHS),
            CheckLBConstraint = tfzn_constr_int_compare(int_le,
                tfzn_int_term_const(LB), IndexTerm, Reification),
            CheckUBConstraint = tfzn_constr_int_compare(int_le,
                IndexTerm, tfzn_int_term_const(UB), Reification),
            set.init(CheckAnns),
            CheckLBConstraintItem =
                tfzn_item_constraint(CheckLBConstraint, CheckAnns),
            CheckUBConstraintItem =
                tfzn_item_constraint(CheckUBConstraint, CheckAnns),
            !:CheckConstraints = !.CheckConstraints ++
                one_tfzn_constraint(CheckLBConstraintItem) ++
                one_tfzn_constraint(CheckUBConstraintItem),
            (
                ILHS = ilhs_true,
                NewIndexLB = int.max(LB, IndexLB),
                NewIndexUB = int.min(UB, IndexUB),
                NewIndexBounds = int_bounds_range(NewIndexLB, NewIndexUB),
                update_int_var_bounds(IndexVar, NewIndexBounds, !Info)
            ;
                ( ILHS = ilhs_var(_)
                ; ILHS = ilhs_reif(_)
                )
            )
        ),

        % The following blocks each implement one of the following
        % calculations.
        %
        % IndexMinusLB = IndexTerm - LB
        % TimesTailSize = IndexMinusLB * TailSize
        % PlusTailOffset = TimesTailSize + TailOffset
        % new Offset = PlusTailOffset

        ( if IndexTerm = tfzn_int_term_const(IndexConstTTS) then
            TimesTailSizeConst = (IndexConstTTS - LB) * TailSize,
            TimesTailSizeTerm = tfzn_int_term_const(TimesTailSizeConst)
        else
            % XXX MaybeIMLBExpr
            MaybeIMLBExpr = no,
            IndexMinusLBVarInfo = var_info_int(var_is_var, var_is_not_output,
                int_bounds_range(0, UB - LB), MaybeIMLBExpr),
            add_tmp_var_int(IndexMinusLBVarInfo, IndexMinusLBVar, !Info),
            IndexMinusLBConstraint = tfzn_constr_int_arith_binop(int_minus,
                IndexTerm, tfzn_int_term_const(LB),
                tfzn_int_term_var(IndexMinusLBVar)),
            IMLBAnn =
                constr_ann_defines_var(tfzn_def_int_var(IndexMinusLBVar)),
            IMLBAnns = set.make_singleton_set(IMLBAnn),
            IndexMinusLBConstraintItem =
                tfzn_item_constraint(IndexMinusLBConstraint, IMLBAnns),
            !:OffsetConstraints = !.OffsetConstraints ++
                one_tfzn_constraint(IndexMinusLBConstraintItem),

            ( if TailSize = 1 then
                TimesTailSizeTerm = tfzn_int_term_var(IndexMinusLBVar)
            else
                % XXX MaybeTTSExpr
                MaybeTTSExpr = no,
                TimesTailSizeVarInfo = var_info_int(var_is_var,
                    var_is_not_output,
                    int_bounds_range(0, (UB - LB) * TailSize), MaybeTTSExpr),
                add_tmp_var_int(TimesTailSizeVarInfo, TimesTailSizeVar, !Info),
                TimesTailSizeConstraint = tfzn_constr_int_arith_binop(
                    int_times, tfzn_int_term_var(IndexMinusLBVar),
                    tfzn_int_term_const(TailSize),
                    tfzn_int_term_var(TimesTailSizeVar)),
                TTSAnn =
                    constr_ann_defines_var(tfzn_def_int_var(TimesTailSizeVar)),
                TTSAnns = set.make_singleton_set(TTSAnn),
                TimesTailSizeConstraintItem =
                    tfzn_item_constraint(TimesTailSizeConstraint, TTSAnns),

                TimesTailSizeTerm = tfzn_int_term_var(TimesTailSizeVar),
                !:OffsetConstraints = !.OffsetConstraints ++
                    one_tfzn_constraint(TimesTailSizeConstraintItem)
            )
        ),

        ( if
            TimesTailSizeTerm = tfzn_int_term_const(TimesTailSizeConstPTO),
            TailOffsetTerm = tfzn_int_term_const(TailOffsetConstPTO)
        then
            OffsetConst = TimesTailSizeConstPTO + TailOffsetConstPTO,
            OffsetTerm = tfzn_int_term_const(OffsetConst)
        else
            % XXX MaybePTOExpr
            MaybePTOExpr = no,
            PlusTailOffsetVarInfo = var_info_int(var_is_var, var_is_not_output,
                int_bounds_range(0, (UB + 1 - LB) * TailSize), MaybePTOExpr),
            add_tmp_var_int(PlusTailOffsetVarInfo, PlusTailOffsetVar, !Info),
            PlusTailOffsetConstraint = tfzn_constr_int_arith_binop(int_plus,
                TimesTailSizeTerm, TailOffsetTerm,
                tfzn_int_term_var(PlusTailOffsetVar)),
            PTOAnn =
                constr_ann_defines_var(tfzn_def_int_var(PlusTailOffsetVar)),
            PTOAnns = set.make_singleton_set(PTOAnn),
            PlusTailOffsetConstraintItem =
                tfzn_item_constraint(PlusTailOffsetConstraint, PTOAnns),

            OffsetTerm = tfzn_int_term_var(PlusTailOffsetVar),
            !:OffsetConstraints = !.OffsetConstraints ++
                one_tfzn_constraint(PlusTailOffsetConstraintItem)
        ),

        % We update TailOffset by adding to it (IndexTerm - LB) * TailSize.
        % This is equivalent to first adding (IndexTerm * TailSize) to it
        % and then subtracting (LB * TailSize) from it. The latter expression
        % is always constant; the former may or may not be.
        (
            IndexTerm = tfzn_int_term_const(IndexConstLin),
            !:Const = !.Const + (IndexConstLin * TailSize)
        ;
            IndexTerm = tfzn_int_term_var(IndexVarLin),
            !:LinearSum = [TailSize - IndexVarLin | !.LinearSum]
        ),
        !:Const = !.Const - (LB * TailSize)
    ).

%-----------------------------------------------------------------------------%
:- end_module translate.array.
%-----------------------------------------------------------------------------%
