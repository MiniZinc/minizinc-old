%-----------------------------------------------------------------------------%
% vim: ts=4 sw=4 et ft=mercury
%-----------------------------------------------------------------------------%
% Copyright (C) 2011 The University of Melbourne and NICTA.
% See the file COPYING for license information.
%-----------------------------------------------------------------------------%
%
% Author: zs.
%
%-----------------------------------------------------------------------------%

:- module translate.float.
:- interface.

:- import_module error_util.
:- import_module tmzn_ast.
:- import_module tfzn_ast.
:- import_module translate.info.

:- import_module assoc_list.
:- import_module list.
:- import_module maybe.

%-----------------------------------------------------------------------------%

    % Translate a float expression from typed MiniZinc to typed FlatZinc
    % in the given context, and return the constraints generated by the
    % translation.
    %
:- pred translate_float_expr_to_tfzn_term(ilhs::in,
    tmzn_float_expr::in, tfzn_float_term::out, tfzn_constraint_set::out,
    tr_info::in, tr_info::out) is det.

:- type float_linear_expr.

    % Convert the given TMznFloatExpr into a form (defined by the type
    % float_linear_expr) from which it is guaranteed to be transformable
    % to a form that matches the expectations of the float_lin_eq constraint
    % (the form is represented by the type float_coeffs_form).
    %
    % Note that every TMznFloatExpr can be transformed into this form,
    % since 1 * TMznFloatExpr + 0 is of this form. Our caller will decide
    % whether implementing TMznFloatExpr using float_lin_eq or similar
    % constraints is USEFUL or not.
    %
:- pred is_float_linear_expr(tr_info::in,
    tmzn_float_expr::in, float_linear_expr::out,
    list(error_spec)::in, list(error_spec)::out) is det.

    % float_coeffs_form([a - X, b - Y], c) represents the expression
    % aX + bY + c.
    %
:- type float_coeffs_form
    --->    float_coeffs_form(
                assoc_list(float, tmzn_float_expr),
                float
            ).

    % Convert a float expression from float_linear_expr form to
    % float_coeffs_form.
    %
:- pred float_linear_expr_build_coeffs_form(float_linear_expr::in,
    float_coeffs_form::out) is det.

    % Does the given float MiniZinc expression represent a constant?
    % If it does, return the constant's value.
    %
:- pred is_float_const_expr(tr_info::in,
    tmzn_float_expr::in, maybe(float)::out,
    list(error_spec)::in, list(error_spec)::out) is det.

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

:- implementation.

:- import_module bounds.
:- import_module error_util.
:- import_module mzn_ops.
:- import_module translate.array.
:- import_module translate.bool.
:- import_module translate.int.
:- import_module translate.vars.
:- import_module types.

:- import_module bool.
:- import_module float.
:- import_module int.
:- import_module map.
:- import_module math.
:- import_module pair.
:- import_module set.
:- import_module set_tree234.
:- import_module string.

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

translate_float_expr_to_tfzn_term(ILHS, TMznFloatExpr, TFznFloatTerm,
        Constraints, !Info) :-
    optimize_special_patterns_float(ILHS, TMznFloatExpr, OptResult, !Info),
    (
        OptResult = opt_all_done(TFznFloatTerm, Constraints)
    ;
        OptResult = opt_flattening_required(MaybeUpdatedTMznFloatExpr),
        translate_float_expr_to_tfzn_term_std(ILHS,
            MaybeUpdatedTMznFloatExpr, TFznFloatTerm, Constraints, !Info)
    ).

%-----------------------------------------------------------------------------%

:- pred optimize_special_patterns_float(ilhs::in, tmzn_float_expr::in,
    optimize_result_float::out, tr_info::in, tr_info::out) is det.

optimize_special_patterns_float(ILHS, TMznFloatExpr, Result, !Info) :-
    is_float_linear_expr(!.Info, TMznFloatExpr, LinearExpr, [], Specs),
    add_errors(Specs, !Info),
    ( if LinearExpr = fle_const(FloatConst) then
        ResultTerm = tfzn_float_term_const(FloatConst),
        Result = opt_all_done(ResultTerm, no_tfzn_constraints)
    else
        float_linear_expr_build_coeffs_form(LinearExpr, CoeffsForm),
        CoeffsForm = float_coeffs_form(CoeffsTMznExprs, Const),
        list.length(CoeffsTMznExprs, NumCoeffsExprs),
        ( if NumCoeffsExprs >= 2 then
            SrcPos = get_src_pos_from_float_expr(TMznFloatExpr),
            translate_float_lin_eq_args_to_tfzn_terms(ILHS, SrcPos,
                CoeffsTMznExprs, CoeffsTFznTerms,
                no_tfzn_constraints, ArgConstraints, !Info),
            tr_info_get_var_info_maps(!.Info, VarInfoMaps0),
            vim_get_float_map(VarInfoMaps0, FloatMap0),
            verify_and_transform_vectors_float(SrcPos, FloatMap0,
                set_tree234.init, CoeffsTFznTerms, Coeffs, TFznVars,
                LinLB, LinUB, !Info),
            float_plus_bounds(Const, Const, LinLB, LinUB, LBZ, UBZ),
            tr_info_get_cse_maps(!.Info, CSEMaps0),
            get_cse_map_float_lin_eq(CSEMaps0, FloatLinEqMap0),
            ( if
                map.search(FloatLinEqMap0, {Coeffs, TFznVars, Const},
                    CSEResult)
            then
                % XXX Can we tighten the bounds on FloatVarZ?
                CSEResult = {FloatVarZ, ConstraintItem},
                Z = tfzn_float_term_var(FloatVarZ)
            else
                FloatBoundsZ = float_bounds_range(LBZ, UBZ),
                MaybeFloatExpr = yes(TMznFloatExpr),
                FloatVarInfoZ = var_info_float(var_is_var, var_is_not_output,
                    FloatBoundsZ, MaybeFloatExpr),
                add_tmp_var_float(FloatVarInfoZ, FloatVarZ, !Info),
                Z = tfzn_float_term_var(FloatVarZ),

                % Given: c1*v1 + c2*v2 + ... + cn*vn + c = z, therefore
                % -1*z + c1*v1 + c2*v2 + ... + cn*vn + c = 0.
                AllCoeffs = [-1.0 | Coeffs],
                AllTFznVars = [FloatVarZ | TFznVars],

                % XXX Should we make the constraint half-reified if ILHS is
                % ilhs_var(BoolVar)? (If we do, we cannot add to CSEMaps0.)
                % If BoolVar = false, then we may not have to compute Z,
                % but testing BoolVar can be more expensive than computing Z.
                Constraint = tfzn_constr_float_linear(float_lin_eq,
                    tfzn_float_array_term_consts(AllCoeffs),
                    tfzn_float_array_term_vars(AllTFznVars),
                    tfzn_float_term_const(Const), not_reified),
                Ann = constr_ann_defines_var(tfzn_def_float_var(FloatVarZ)),
                Anns = set.make_singleton_set(Ann),
                ConstraintItem = tfzn_item_constraint(Constraint, Anns),

                map.det_insert({Coeffs, TFznVars, Const},
                    {FloatVarZ, ConstraintItem},
                    FloatLinEqMap0, FloatLinEqMap),
                set_cse_map_float_lin_eq(FloatLinEqMap, CSEMaps0, CSEMaps),
                tr_info_set_cse_maps(CSEMaps, !Info)
            ),
            Constraints = ArgConstraints ++
                one_tfzn_constraint(ConstraintItem),
            Result = opt_all_done(Z, Constraints)
        else
            % We haven't matched the pattern of any implemented optimization.

            % XXX If LinearExpr is of the form c1*v1 + c, but this is derived
            % from a more complex TMznFloatExpr like c1a*v1 + c1b*v1 + ca + cb
            % where c1 = c1a+c1b and c = ca + cb, then we should construct
            % and return a tmzn expression for c1*v1 + c. The reason why we
            % don't (yet) do so is that this requires setting useful src_locns
            % on the constructed tmzn_int_exprs, and without an otherwise
            % working transformation, we can't experimentally verify what
            % src_locn would be useful.

            Result = opt_flattening_required(TMznFloatExpr)
        )
    ).

:- pred translate_float_lin_eq_args_to_tfzn_terms(ilhs::in, src_pos::in,
    assoc_list(float, tmzn_float_expr)::in,
    assoc_list(float, tfzn_float_term)::out,
    tfzn_constraint_set::in, tfzn_constraint_set::out,
    tr_info::in, tr_info::out) is det.

translate_float_lin_eq_args_to_tfzn_terms(_ILHS, _SrcPos, [], [],
        !Constraints, !Info).
translate_float_lin_eq_args_to_tfzn_terms(ILHS, SrcPos,
        [Coeff - TMznExpr | CoeffsTMznExprs],
        [Coeff - TFznTerm | CoeffsTFznTerms], !Constraints, !Info) :-
    % XXX SrcPos
    translate_float_expr_to_tfzn_term(ILHS, TMznExpr, TFznTerm,
        HeadConstraints, !Info),
    !:Constraints = !.Constraints ++ HeadConstraints,
    translate_float_lin_eq_args_to_tfzn_terms(ILHS, SrcPos,
        CoeffsTMznExprs, CoeffsTFznTerms, !Constraints, !Info).

:- pred verify_and_transform_vectors_float(src_pos::in, var_info_map_float::in,
    set_tree234(tfzn_float_var)::in, assoc_list(float, tfzn_float_term)::in,
    list(float)::out, list(tfzn_float_var)::out, float::out, float::out,
    tr_info::in, tr_info::out) is det.

verify_and_transform_vectors_float(_, _, _, [], [], [], 0.0, 0.0, !Info).
verify_and_transform_vectors_float(SrcPos, FloatMap, !.SeenVars,
        [CoeffTFznTerm | CoeffsTFznTerms], Coeffs, TFznVars, LB, UB, !Info) :-
    CoeffTFznTerm = Coeff - TFznTerm,
    (
        TFznTerm = tfzn_float_term_const(_),
        add_internal_error_info($pred, phase_constraint, SrcPos,
            "constant term", !Info),
        TFznVar = tfzn_float_var_named("dummy")
    ;
        TFznTerm = tfzn_float_term_var(TFznVar),
        set_tree234.is_member(!.SeenVars, TFznVar, IsMember),
        (
            IsMember = yes,
            add_internal_error_info($pred, phase_constraint, SrcPos,
                "repeated var", !Info)
        ;
            IsMember = no,
            set_tree234.insert(TFznVar, !SeenVars)
        )
    ),
    verify_and_transform_vectors_float(SrcPos, FloatMap, !.SeenVars,
        CoeffsTFznTerms, TailCoeffs, TailTFznVars, TailLB, TailUB, !Info),
    Coeffs = [Coeff | TailCoeffs],
    TFznVars = [TFznVar | TailTFznVars],

    map.lookup(FloatMap, TFznVar, VarInfo),
    % XXX use VarExpr to update the bounds?
    VarInfo = var_info_float(_Inst, _Output, Bounds, _MaybeVarExpr),
    Bounds = float_bounds_range(HeadLB, HeadUB),
    float_times_bounds(Coeff, Coeff, HeadLB, HeadUB, CoeffHeadLB, CoeffHeadUB),
    float_plus_bounds(CoeffHeadLB, CoeffHeadUB, TailLB, TailUB, LB, UB).

%-----------------------------------------------------------------------------%

:- type float_linear_expr
    --->    fle_const(float)
    ;       fle_translate_to_var(tmzn_float_expr)
    ;       fle_sum(float_linear_expr, float_linear_expr)
    ;       fle_scale(float, float_linear_expr).

is_float_linear_expr(Info, TMznFloatExpr, LinearExpr, !Specs) :-
    % TMznFloatExpr may be a constant expression even if it is NOT
    % of the form tmzn_float_expr_const(_).
    is_float_const_expr(Info, TMznFloatExpr, MaybeFloatConst, !Specs),
    (
        MaybeFloatConst = yes(FloatConst),
        LinearExpr = fle_const(FloatConst)
    ;
        MaybeFloatConst = no,
        (
            TMznFloatExpr = tmzn_float_expr_const(SrcPos, _Float),
            add_nyi_error($pred, phase_constraint, SrcPos,
                "non-constant constant", !Specs),
            LinearExpr = fle_translate_to_var(TMznFloatExpr)
        ;
            TMznFloatExpr = tmzn_float_expr_f2f(_SrcPos, F2FOp, TMznFloatA),
            (
                F2FOp = f2f_add,
                is_float_linear_expr(Info, TMznFloatA, LinearExpr, !Specs)
            ;
                F2FOp = f2f_sub,
                is_float_linear_expr(Info, TMznFloatA, LinearExprA, !Specs),
                LinearExpr = fle_scale(-1.0, LinearExprA)
            ;
                ( F2FOp = f2f_lb
                ; F2FOp = f2f_ub
                ; F2FOp = f2f_abs
                ; F2FOp = f2f_sqrt
                ; F2FOp = f2f_exp
                ; F2FOp = f2f_ln
                ; F2FOp = f2f_log10
                ; F2FOp = f2f_log2
                ; F2FOp = f2f_sin
                ; F2FOp = f2f_cos
                ; F2FOp = f2f_tan
                ; F2FOp = f2f_sinh
                ; F2FOp = f2f_cosh
                ; F2FOp = f2f_tanh
                ; F2FOp = f2f_asin
                ; F2FOp = f2f_acos
                ; F2FOp = f2f_atan
                ; F2FOp = f2f_fix
                ),
                LinearExpr = fle_translate_to_var(TMznFloatExpr)
            )
        ;
            TMznFloatExpr = tmzn_float_expr_ff2f(_SrcPos, FF2FOp,
                TMznFloatA, TMznFloatB),
            (
                FF2FOp = ff2f_add,
                is_float_linear_expr(Info, TMznFloatA, LinearExprA, !Specs),
                is_float_linear_expr(Info, TMznFloatB, LinearExprB, !Specs),
                LinearExpr = fle_sum(LinearExprA, LinearExprB)
            ;
                FF2FOp = ff2f_sub,
                is_float_linear_expr(Info, TMznFloatA, LinearExprA, !Specs),
                is_float_linear_expr(Info, TMznFloatB, LinearExprB, !Specs),
                LinearExpr = fle_sum(LinearExprA, fle_scale(-1.0, LinearExprB))
            ;
                FF2FOp = ff2f_mul,
                % We don't care here whether FloatConstA or FloatConstB are
                % equal to 1; we will simplify such cases later.
                is_float_const_expr(Info, TMznFloatA, MaybeFloatConstA,
                    !Specs),
                (
                    MaybeFloatConstA = yes(FloatConstA),
                    is_float_linear_expr(Info, TMznFloatB, LinearExprB,
                        !Specs),
                    LinearExpr = fle_scale(FloatConstA, LinearExprB)
                ;
                    MaybeFloatConstA = no,
                    is_float_const_expr(Info, TMznFloatB, MaybeFloatConstB,
                        !Specs),
                    (
                        MaybeFloatConstB = yes(FloatConstB),
                        is_float_linear_expr(Info, TMznFloatA, LinearExprA,
                            !Specs),
                        LinearExpr = fle_scale(FloatConstB, LinearExprA)
                    ;
                        MaybeFloatConstB = no,
                        % TMznFloatB is non-linear.
                        LinearExpr = fle_translate_to_var(TMznFloatExpr)
                    )
                )
            ;
                FF2FOp = ff2f_div,
                is_float_const_expr(Info, TMznFloatB, MaybeFloatConstB,
                    !Specs),
                (
                    MaybeFloatConstB = yes(FloatConstB),
                    ( if FloatConstB = 1.0 then
                        is_float_linear_expr(Info, TMznFloatA, LinearExpr,
                            !Specs)
                    else if FloatConstB = -1.0 then
                        is_float_linear_expr(Info, TMznFloatA, LinearExprA,
                            !Specs),
                        LinearExpr = fle_scale(-1.0, LinearExprA)
                    else
                        % We could translate TMznFloatExpr into
                        % fle_scale(1/FloatConstB, LinearExprA) only if
                        % the coefficients were floats, not ints.
                        LinearExpr = fle_translate_to_var(TMznFloatExpr)
                    )
                ;
                    MaybeFloatConstB = no,
                    LinearExpr = fle_translate_to_var(TMznFloatExpr)
                )
            ;
                ( FF2FOp = ff2f_min
                ; FF2FOp = ff2f_max
                ; FF2FOp = ff2f_pow
                ; FF2FOp = ff2f_log
                ),
                LinearExpr = fle_translate_to_var(TMznFloatExpr)
            )
%       ;
%           TMznFloatExpr = tmzn_float_expr_int(_SrcPos, TMznIntExpr),
%           ( if is_int_const_expr(TMznIntExpr, IntConst) 
%           then
%               LinearExpr = fle_const(float(IntConst))
%           else
%               LinearExpr = fle_translate_to_var(TMznFloatExpr)
%           )
        ;
            ( TMznFloatExpr = tmzn_float_expr_var(_SrcPos, _TMznFloatVar)
            ; TMznFloatExpr = tmzn_float_expr_i2f(_SrcPos, _Op, _TMznIntExpr)
            ; TMznFloatExpr = tmzn_float_expr_ite(_SrcPos, _Cond, _Then, _Else)
            ),
            LinearExpr = fle_translate_to_var(TMznFloatExpr)
        )
    ).

%-----------------------------------------------------------------------------%

float_linear_expr_build_coeffs_form(LinearExpr, CoeffsForm) :-
    Scale0 = 1.0,
    map.init(CoeffsMap0),
    Const0 = 0.0,
    float_linear_expr_build_coeffs(Scale0, LinearExpr, CoeffsMap0, CoeffsMap,
        Const0, Const),
    map.to_assoc_list(CoeffsMap, CoeffsExprFloats),
    assoc_list.reverse_members(CoeffsExprFloats, CoeffsFloatExprs),
    CoeffsForm = float_coeffs_form(CoeffsFloatExprs, Const).

:- pred float_linear_expr_build_coeffs(float::in, float_linear_expr::in,
    map(tmzn_float_expr, float)::in, map(tmzn_float_expr, float)::out,
    float::in, float::out) is det.

float_linear_expr_build_coeffs(Scale, LinearExpr, !CoeffsMap, !Const) :-
    (
        LinearExpr = fle_const(K),
        !:Const = !.Const + K
    ;
        LinearExpr = fle_translate_to_var(TMznFloatExpr),
        ( if map.search(!.CoeffsMap, TMznFloatExpr, OldCoeff) then
            UpdatedCoeff = OldCoeff + Scale,
            ( if UpdatedCoeff = 0.0 then
                % We do this so that testing the size of the final CoeffsForm
                % is more meaningful.
                map.delete(TMznFloatExpr, !CoeffsMap)
            else
                map.det_update(TMznFloatExpr, UpdatedCoeff, !CoeffsMap)
            )
        else
            map.det_insert(TMznFloatExpr, Scale, !CoeffsMap)
        )
    ;
        LinearExpr = fle_sum(LinearExprA, LinearExprB),
        float_linear_expr_build_coeffs(Scale, LinearExprA, !CoeffsMap, !Const),
        float_linear_expr_build_coeffs(Scale, LinearExprB, !CoeffsMap, !Const)
    ;
        LinearExpr = fle_scale(K, LinearExprA),
        ( if K = 0.0 then
            true
        else
            float_linear_expr_build_coeffs(Scale * K, LinearExprA,
                !CoeffsMap, !Const)
        )
    ).

%-----------------------------------------------------------------------------%

is_float_const_expr(Info, TMznFloatExpr, MaybeFloatConst, !Specs) :-
    (
        TMznFloatExpr = tmzn_float_expr_const(_SrcPos, FloatConst),
        MaybeFloatConst = yes(FloatConst)
    ;
        TMznFloatExpr = tmzn_float_expr_var(_SrcPos, TMznFloatVar),
        tr_info_get_var_info_maps(Info, VarInfoMaps),
        vim_get_float_map(VarInfoMaps, FloatMap),
        ( if
            TMznFloatVar = tmzn_float_var_named(FloatVarName),
            TFznFloatVar = tfzn_float_var_named(FloatVarName),
            map.search(FloatMap, TFznFloatVar, FloatVarInfo),
            FloatVarInfo ^ vif_bounds =
                float_bounds_range(FloatConst, FloatConst)
        then
            MaybeFloatConst = yes(FloatConst)
        else
            MaybeFloatConst = no
        )
    ;
        TMznFloatExpr = tmzn_float_expr_i2f(_SrcPos, I2FOp, TMznIntA),
        is_int_const_expr(Info, TMznIntA, MaybeIntConstA, !Specs),
        (
            MaybeIntConstA = yes(IntConstA),
            translate_par_int_to_float(I2FOp, IntConstA, FloatConst),
            MaybeFloatConst = yes(FloatConst)
        ;
            MaybeIntConstA = no,
            MaybeFloatConst = no
        )
    ;
        TMznFloatExpr = tmzn_float_expr_f2f(SrcPos, F2FOp, TMznFloatA),
        is_float_const_expr(Info, TMznFloatA, MaybeFloatConstA, !Specs),
        (
            MaybeFloatConstA = yes(FloatConstA),
            translate_par_float_to_float(SrcPos, F2FOp, FloatConstA,
                FloatConst, !Specs),
            MaybeFloatConst = yes(FloatConst)
        ;
            MaybeFloatConstA = no,
            MaybeFloatConst = no
        )
    ;
        TMznFloatExpr = tmzn_float_expr_ff2f(SrcPos, FF2FOp,
            TMznFloatA, TMznFloatB),
        is_float_const_expr(Info, TMznFloatA, MaybeFloatConstA, !Specs),
        is_float_const_expr(Info, TMznFloatB, MaybeFloatConstB, !Specs),
        ( if
            MaybeFloatConstA = yes(FloatConstA),
            MaybeFloatConstB = yes(FloatConstB)
        then
            translate_par_float_par_float_to_float(SrcPos, FF2FOp,
                FloatConstA, FloatConstB, FloatConst, !Specs),
            MaybeFloatConst = yes(FloatConst)
        else
            MaybeFloatConst = no
        )
    ;
        TMznFloatExpr = tmzn_float_expr_ite(_SrcPos, Cond, Then, Else),
        is_bool_const_expr(Info, Cond, MaybeCondConst, !Specs),
        (
            MaybeCondConst = yes(CondConst),
            (
                CondConst = yes,
                is_float_const_expr(Info, Then, MaybeThenConst, !Specs),
                MaybeFloatConst = MaybeThenConst
            ;
                CondConst = no,
                is_float_const_expr(Info, Else, MaybeElseConst, !Specs),
                MaybeFloatConst = MaybeElseConst
            )
        ;
            MaybeCondConst = no,
            MaybeFloatConst = no
        )
    ).

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

:- pred translate_float_expr_to_tfzn_term_std(ilhs::in,
    tmzn_float_expr::in, tfzn_float_term::out, tfzn_constraint_set::out,
    tr_info::in, tr_info::out) is det.

translate_float_expr_to_tfzn_term_std(ILHS, TMznFloatExpr, TFznFloatTerm,
        Constraints, !Info) :-
    (
        TMznFloatExpr = tmzn_float_expr_const(_SrcPos, Float),
        % XXX This should have been caught and handled by the optimizer.
        TFznFloatTerm = tfzn_float_term_const(Float),
        Constraints = no_tfzn_constraints
    ;
        TMznFloatExpr = tmzn_float_expr_var(SrcPos, TMznFloatVar),
        (
            TMznFloatVar = tmzn_float_var_named(FloatVarName),
            % XXX Could we optimize this if FloatVarName has had its value
            % fixed already, by earlier constraints?
            TFznFloatVar = tfzn_float_var_named(FloatVarName),
            TFznFloatTerm = tfzn_float_term_var(TFznFloatVar),
            Constraints = no_tfzn_constraints
        ;
            TMznFloatVar = tmzn_float_var_anon,
            % XXX Inst: should we take it from an extended TMznFloatExpr?
            % XXX Bounds: should we take it from an extended TMznFloatExpr?
            MaybeTmpVarExpr = no,
            TmpVarInfo = var_info_float(var_is_var, var_is_not_output,
                float_bounds_range(float_minus_infinity, float_plus_infinity),
                MaybeTmpVarExpr),
            add_tmp_var_float(TmpVarInfo, TFznFloatVar, !Info),
            TFznFloatTerm = tfzn_float_term_var(TFznFloatVar),
            Constraints = no_tfzn_constraints
        ;
            TMznFloatVar = tmzn_float_var_array_slot(TMznFloatArrayExpr,
                IndexExprs),
            translate_float_array_access(ILHS, SrcPos, TMznFloatArrayExpr,
                IndexExprs, TFznFloatTerm, Constraints, !Info)
        )
    ;
        TMznFloatExpr = tmzn_float_expr_i2f(SrcPos, I2FOp, TMznIntA),
        translate_int_expr_to_tfzn_term(ILHS,
            TMznIntA, TFznIntA, ConstraintsA, !Info),
        translate_int_to_float(ILHS, SrcPos, I2FOp, TFznIntA, TFznFloatTerm,
            ConstraintsOp, !Info),
        Constraints = ConstraintsA ++ ConstraintsOp
    ;
        TMznFloatExpr = tmzn_float_expr_f2f(SrcPos, F2FOp, TMznFloatA),
        translate_float_expr_to_tfzn_term(ILHS,
            TMznFloatA, TFznFloatA, ConstraintsA, !Info),
        translate_float_to_float(ILHS, SrcPos, F2FOp, TFznFloatA,
            TFznFloatTerm, ConstraintsOp, !Info),
        Constraints = ConstraintsA ++ ConstraintsOp
    ;
        TMznFloatExpr = tmzn_float_expr_ff2f(SrcPos, FF2FOp,
            TMznFloatA, TMznFloatB),
        translate_float_expr_to_tfzn_term(ILHS,
            TMznFloatA, TFznFloatA, ConstraintsA, !Info),
        translate_float_expr_to_tfzn_term(ILHS,
            TMznFloatB, TFznFloatB, ConstraintsB, !Info),
        translate_float_float_to_float(ILHS, SrcPos, FF2FOp,
            TFznFloatA, TFznFloatB, TFznFloatTerm, ConstraintsOp, !Info),
        Constraints = ConstraintsA ++ ConstraintsB ++ ConstraintsOp
    ;
        TMznFloatExpr = tmzn_float_expr_ite(SrcPos, _BoolCondExpr,
            _FloatThenExpr, _FloatElseExpr),
        add_nyi_error_info($pred, phase_constraint, SrcPos, "ite", !Info),
        TFznFloatTerm = tfzn_float_term_const(0.0),
        Constraints = no_tfzn_constraints
    ).

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

:- pred translate_int_to_float(ilhs::in, src_pos::in, int_to_float_op::in,
    tfzn_int_term::in, tfzn_float_term::out, tfzn_constraint_set::out,
    tr_info::in, tr_info::out) is det.

translate_int_to_float(ILHS, SrcPos, I2FOp, A, Z, Constraints, !Info) :-
    (
        A = tfzn_int_term_const(IntA),
        add_internal_error_info($pred, phase_constraint, SrcPos,
            "const not caught by optimizer", !Info),
        translate_par_int_to_float(I2FOp, IntA, FloatZ),
        Z = tfzn_float_term_const(FloatZ),
        Constraints = no_tfzn_constraints
    ;
        A = tfzn_int_term_var(IntVarA),
        translate_var_int_to_float(ILHS, I2FOp, IntVarA, Z, Constraints, !Info)
    ).

:- pred translate_par_int_to_float(int_to_float_op::in, int::in, float::out)
    is det.

translate_par_int_to_float(I2FOp, IntConstA, FloatConst) :-
    (
        I2FOp = i2f_int2float,
        FloatConst = float(IntConstA)
    ).

:- pred translate_var_int_to_float(ilhs::in, int_to_float_op::in,
    tfzn_int_var::in, tfzn_float_term::out, tfzn_constraint_set::out,
    tr_info::in, tr_info::out) is det.

translate_var_int_to_float(_ILHS, I2FOp, IntVarA, Z, Constraints, !Info) :-
    (
        I2FOp = i2f_int2float,
        int_bounds_range(LBA, UBA) = find_int_var_bounds(!.Info, IntVarA),

        tr_info_get_cse_maps(!.Info, CSEMaps0),
        get_cse_map_i2f(CSEMaps0, I2FMap0),
        A = tfzn_int_term_var(IntVarA),
        ( if map.search(I2FMap0, {int_to_float, A}, CSEResult) then
            CSEResult = {FloatVarZ, ConstraintItem},
            Z = tfzn_float_term_var(FloatVarZ)
        else
            LBZ = float(LBA),
            UBZ = float(UBA),
            FloatBoundsZ = float_bounds_range(LBZ, UBZ),
            % XXX Can we use any IntExpr recorded for IntVarA to set
            % MaybeFloatExprZ?
            MaybeFloatExprZ = no,
            FloatVarInfoZ = var_info_float(var_is_var, var_is_not_output,
                FloatBoundsZ, MaybeFloatExprZ),
            add_tmp_var_float(FloatVarInfoZ, FloatVarZ, !Info),
            Z = tfzn_float_term_var(FloatVarZ),

            % XXX Should we make the constraint half-reified if ILHS is
            % ilhs_var(BoolVar)? (If we do, we cannot add to CSEMaps0.)
            % If BoolVar = false, then we may not have to compute Z,
            % but testing BoolVar can be more expensive than computing Z.
            Constraint = tfzn_constr_int_to_float(int_to_float, A, FloatVarZ),
            Ann = constr_ann_defines_var(tfzn_def_float_var(FloatVarZ)),
            Anns = set.make_singleton_set(Ann),
            ConstraintItem = tfzn_item_constraint(Constraint, Anns),

            map.det_insert({int_to_float, A}, {FloatVarZ, ConstraintItem},
                I2FMap0, I2FMap),
            set_cse_map_i2f(I2FMap, CSEMaps0, CSEMaps),
            tr_info_set_cse_maps(CSEMaps, !Info)
        ),
        Constraints = one_tfzn_constraint(ConstraintItem)
    ).

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

:- pred translate_float_to_float(ilhs::in, src_pos::in, float_to_float_op::in,
    tfzn_float_term::in, tfzn_float_term::out, tfzn_constraint_set::out,
    tr_info::in, tr_info::out) is det.

translate_float_to_float(ILHS, SrcPos, F2FOp, A, Z, Constraints, !Info) :-
    (
        A = tfzn_float_term_const(FloatA),
        add_nyi_error_info($pred, phase_constraint, SrcPos,
            "const not caught by optimizer", !Info),
        translate_par_float_to_float(SrcPos, F2FOp, FloatA, FloatZ, [], Specs),
        add_errors(Specs, !Info),
        Z = tfzn_float_term_const(FloatZ),
        Constraints = no_tfzn_constraints
    ;
        A = tfzn_float_term_var(FloatVarA),
        translate_var_float_to_float(ILHS, SrcPos, F2FOp, FloatVarA, Z,
            Constraints, !Info)
    ).

:- pred translate_par_float_to_float(src_pos::in, float_to_float_op::in,
    float::in, float::out, list(error_spec)::in, list(error_spec)::out) is det.

translate_par_float_to_float(SrcPos, F2FOp, FloatA, FloatZ, !Specs) :-
    (
        ( F2FOp = f2f_add,      FloatZ = FloatA
        ; F2FOp = f2f_sub,      FloatZ = -FloatA
        ; F2FOp = f2f_lb,       FloatZ = FloatA
        ; F2FOp = f2f_ub,       FloatZ = FloatA
        ; F2FOp = f2f_abs,      FloatZ = float.abs(FloatA)
        ; F2FOp = f2f_exp,      FloatZ = math.exp(FloatA)
        ; F2FOp = f2f_sin,      FloatZ = math.sin(FloatA)
        ; F2FOp = f2f_cos,      FloatZ = math.cos(FloatA)
        ; F2FOp = f2f_tan,      FloatZ = math.tan(FloatA)
        ; F2FOp = f2f_sinh,     FloatZ = math.sinh(FloatA)
        ; F2FOp = f2f_cosh,     FloatZ = math.cosh(FloatA)
        ; F2FOp = f2f_tanh,     FloatZ = math.tanh(FloatA)
        ; F2FOp = f2f_asin,     FloatZ = math.asin(FloatA)
        ; F2FOp = f2f_acos,     FloatZ = math.acos(FloatA)
        ; F2FOp = f2f_atan,     FloatZ = math.atan(FloatA)
        ; F2FOp = f2f_fix,      FloatZ = FloatA
        )
    ;
        F2FOp = f2f_sqrt,
        ( if FloatA >= 0.0 then
            FloatZ = math.sqrt(FloatA)
        else
            add_user_error($pred, phase_constraint, SrcPos,
                "Negative argument to 'sqrt'", !Specs),
            FloatZ = 0.0
        )
    ;
        ( F2FOp = f2f_ln,       Func = math.ln
        ; F2FOp = f2f_log10,    Func = math.log10
        ; F2FOp = f2f_log2,     Func = math.log2
        ),
        ( if FloatA = 0.0 then
            is_float_to_float_op(F2FOpStr, F2FOp),
            add_user_error($pred, phase_constraint, SrcPos,
                "Zero argument to '" ++ F2FOpStr ++ "'", !Specs),
            FloatZ = 0.0
        else
            FloatZ = Func(FloatA)
        )
    ).

:- pred translate_var_float_to_float(ilhs::in, src_pos::in,
    float_to_float_op::in, tfzn_float_var::in, tfzn_float_term::out,
    tfzn_constraint_set::out, tr_info::in, tr_info::out) is det.

translate_var_float_to_float(ILHS, SrcPos, F2FOp, FloatVarA, Z, Constraints,
        !Info) :-
    (
        F2FOp = f2f_add,
        Z = tfzn_float_term_var(FloatVarA),
        Constraints = no_tfzn_constraints
    ;
        F2FOp = f2f_sub,
        % XXX We could see whether we already have a constraint like this.
        tr_info_get_cse_maps(!.Info, CSEMaps0),
        get_cse_map_f2f(CSEMaps0, F2FMap0),
        A = tfzn_float_term_var(FloatVarA),
        ( if map.search(F2FMap0, {float_negate, A}, CSEResult) then
            % XXX Can we tighten the bounds on FloatVarZ?
            CSEResult = {FloatVarZ, ConstraintItem},
            Z = tfzn_float_term_var(FloatVarZ)
        else
            float_bounds_range(LBA, UBA) =
                find_float_var_bounds(!.Info, FloatVarA),
            float_times_bounds(-1.0, -1.0, LBA, UBA, LBZ, UBZ),
            FloatBoundsZ = float_bounds_range(LBZ, UBZ),
            % XXX If we have FloatExprA, can we use it to set MaybeFloatExprZ?
            MaybeFloatBoundsZ = no,
            FloatVarInfoZ = var_info_float(var_is_var, var_is_not_output,
                FloatBoundsZ, MaybeFloatBoundsZ),
            add_tmp_var_float(FloatVarInfoZ, FloatVarZ, !Info),
            Z = tfzn_float_term_var(FloatVarZ),

            % XXX Should we make the constraint half-reified if ILHS is
            % ilhs_var(BoolVar)? (If we do, we cannot add to CSEMaps0.)
            % If BoolVar = false, then we may not have to compute Z,
            % but testing BoolVar can be more expensive than computing Z.
            Constraint = tfzn_constr_float_arith_unop(float_negate, A, Z),
            Ann = constr_ann_defines_var(tfzn_def_float_var(FloatVarZ)),
            Anns = set.make_singleton_set(Ann),
            ConstraintItem = tfzn_item_constraint(Constraint, Anns),

            map.det_insert({float_negate, A}, {FloatVarZ, ConstraintItem},
                F2FMap0, F2FMap),
            set_cse_map_f2f(F2FMap, CSEMaps0, CSEMaps),
            tr_info_set_cse_maps(CSEMaps, !Info)
        ),
        Constraints = one_tfzn_constraint(ConstraintItem)
    ;
        F2FOp = f2f_lb,
        float_bounds_range(LBA, _UBA) =
            find_float_var_bounds(!.Info, FloatVarA),
        ( if LBA = float_minus_infinity then
            add_user_error_info($pred, phase_constraint, SrcPos,
                "Cannot infer lower bound", !Info),
            Z = tfzn_float_term_const(0.0),
            Constraints = no_tfzn_constraints
        else
            Z = tfzn_float_term_const(LBA),
            Constraints = no_tfzn_constraints
        )
    ;
        F2FOp = f2f_ub,
        float_bounds_range(_LBA, UBA) =
            find_float_var_bounds(!.Info, FloatVarA),
        ( if UBA = float_plus_infinity then
            add_user_error_info($pred, phase_constraint, SrcPos,
                "Cannot infer upper bound", !Info),
            Z = tfzn_float_term_const(0.0),
            Constraints = no_tfzn_constraints
        else
            Z = tfzn_float_term_const(UBA),
            Constraints = no_tfzn_constraints
        )
    ;
        F2FOp = f2f_abs,
        float_bounds_range(LBA, UBA) =
            find_float_var_bounds(!.Info, FloatVarA),
        ( if LBA < 0.0, 0.0 < UBA then
            % A may be negative, zero or positive.
            tr_info_get_cse_maps(!.Info, CSEMaps0),
            get_cse_map_f2f(CSEMaps0, F2FMap0),
            A = tfzn_float_term_var(FloatVarA),
            ( if map.search(F2FMap0, {float_abs, A}, CSEResult) then
                % XXX Can we tighten the bounds on FloatVarZ?
                CSEResult = {FloatVarZ, ConstraintItem},
                Z = tfzn_float_term_var(FloatVarZ)
            else
                LBZ = 0.0,
                ( if
                    ( LBA = float_minus_infinity ; UBA = float_plus_infinity )
                then
                    UBZ = float_plus_infinity
                else
                    UBZ = float.max(-LBA, UBA)
                ),
                FloatBoundsZ = float_bounds_range(LBZ, UBZ),
                % XXX If we have FloatExprA, can we use it to set
                % MaybeFloatExprZ?
                MaybeFloatBoundsZ = no,
                FloatVarInfoZ = var_info_float(var_is_var, var_is_not_output,
                    FloatBoundsZ, MaybeFloatBoundsZ),
                add_tmp_var_float(FloatVarInfoZ, FloatVarZ, !Info),
                Z = tfzn_float_term_var(FloatVarZ),

                % XXX Should we make the constraint half-reified if ILHS is
                % ilhs_var(BoolVar)? (If we do, we cannot add to CSEMaps0.)
                % If BoolVar = false, then we may not have to compute Z,
                % but testing BoolVar can be more expensive than computing Z.
                Constraint = tfzn_constr_float_arith_unop(float_abs, A, Z),
                Ann = constr_ann_defines_var(tfzn_def_float_var(FloatVarZ)),
                Anns = set.make_singleton_set(Ann),
                ConstraintItem = tfzn_item_constraint(Constraint, Anns),

                map.det_insert({float_abs, A}, {FloatVarZ, ConstraintItem},
                    F2FMap0, F2FMap),
                set_cse_map_f2f(F2FMap, CSEMaps0, CSEMaps),
                tr_info_set_cse_maps(CSEMaps, !Info)
            ),
            Constraints = one_tfzn_constraint(ConstraintItem)
        else if UBA < 0.0 then
            % A may only be negative.
            % Instead of computing the absolute value, compute the negation.
            translate_var_float_to_float(ILHS, SrcPos, f2f_sub, FloatVarA, Z,
                Constraints, !Info)
        else
            % A may only be zero or positive.
            % There is no need for the absolute value operation: it would
            % always return its operand.
            Z = tfzn_float_term_var(FloatVarA),
            Constraints = no_tfzn_constraints
        )
    ;
        F2FOp = f2f_exp,
        float_bounds_range(LBA, UBA) =
            find_float_var_bounds(!.Info, FloatVarA),
        ( if LBA = float_minus_infinity then
            LBZ = 0.0
        else
            LBZ = math.exp(LBA)
        ),
        ( if UBA = float_plus_infinity then
            UBZ = float_plus_infinity
        else
            UBZ = math.exp(LBA)
        ),
        FloatBoundsZ = float_bounds_range(LBZ, UBZ),

        tr_info_get_cse_maps(!.Info, CSEMaps0),
        get_cse_map_f2f(CSEMaps0, F2FMap0),
        A = tfzn_float_term_var(FloatVarA),
        ( if map.search(F2FMap0, {float_exp, A}, CSEResult) then
            % XXX We could refine FloatVarZ's bounds.
            CSEResult = {FloatVarZ, ConstraintItem},
            Z = tfzn_float_term_var(FloatVarZ)
        else
            % XXX If we have FloatExprA, can we use it to set MaybeFloatExprZ?
            MaybeFloatBoundsZ = no,
            FloatVarInfoZ = var_info_float(var_is_var, var_is_not_output,
                FloatBoundsZ, MaybeFloatBoundsZ),
            add_tmp_var_float(FloatVarInfoZ, FloatVarZ, !Info),
            Z = tfzn_float_term_var(FloatVarZ),

            % XXX Should we make the constraint half-reified if ILHS is
            % ilhs_var(BoolVar)? (If we do, we cannot add to CSEMaps0.)
            % If BoolVar = false, then we may not have to compute Z,
            % but testing BoolVar can be more expensive than computing Z.
            Constraint = tfzn_constr_float_arith_unop(float_exp, A, Z),
            Ann = constr_ann_defines_var(tfzn_def_float_var(FloatVarZ)),
            Anns = set.make_singleton_set(Ann),
            ConstraintItem = tfzn_item_constraint(Constraint, Anns),

            map.det_insert({float_exp, A}, {FloatVarZ, ConstraintItem},
                F2FMap0, F2FMap),
            set_cse_map_f2f(F2FMap, CSEMaps0, CSEMaps),
            tr_info_set_cse_maps(CSEMaps, !Info)
        ),
        Constraints = one_tfzn_constraint(ConstraintItem)
    ;
        ( F2FOp = f2f_sin, Op = float_sin
        ; F2FOp = f2f_cos, Op = float_cos
        ),
        % XXX For some ranges of A, we could generate tighter bounds.
        FloatBoundsZ = float_bounds_range(-1.0, 1.0),

        tr_info_get_cse_maps(!.Info, CSEMaps0),
        get_cse_map_f2f(CSEMaps0, F2FMap0),
        A = tfzn_float_term_var(FloatVarA),
        ( if map.search(F2FMap0, {Op, A}, CSEResult) then
            % XXX We could refine FloatVarZ's bounds.
            CSEResult = {FloatVarZ, ConstraintItem},
            Z = tfzn_float_term_var(FloatVarZ)
        else
            % XXX If we have FloatExprA, can we use it to set MaybeFloatExprZ?
            MaybeFloatBoundsZ = no,
            FloatVarInfoZ = var_info_float(var_is_var, var_is_not_output,
                FloatBoundsZ, MaybeFloatBoundsZ),
            add_tmp_var_float(FloatVarInfoZ, FloatVarZ, !Info),
            Z = tfzn_float_term_var(FloatVarZ),

            % XXX Should we make the constraint half-reified if ILHS is
            % ilhs_var(BoolVar)? (If we do, we cannot add to CSEMaps0.)
            % If BoolVar = false, then we may not have to compute Z,
            % but testing BoolVar can be more expensive than computing Z.
            Constraint = tfzn_constr_float_arith_unop(Op, A, Z),
            Ann = constr_ann_defines_var(tfzn_def_float_var(FloatVarZ)),
            Anns = set.make_singleton_set(Ann),
            ConstraintItem = tfzn_item_constraint(Constraint, Anns),

            map.det_insert({Op, A}, {FloatVarZ, ConstraintItem},
                F2FMap0, F2FMap),
            set_cse_map_f2f(F2FMap, CSEMaps0, CSEMaps),
            tr_info_set_cse_maps(CSEMaps, !Info)
        ),
        Constraints = one_tfzn_constraint(ConstraintItem)
    ;
        ( F2FOp = f2f_sqrt
        ; F2FOp = f2f_ln
        ; F2FOp = f2f_log10
        ; F2FOp = f2f_log2
        ; F2FOp = f2f_tan
        ; F2FOp = f2f_sinh
        ; F2FOp = f2f_cosh
        ; F2FOp = f2f_tanh
        ; F2FOp = f2f_asin
        ; F2FOp = f2f_acos
        ; F2FOp = f2f_atan
        ; F2FOp = f2f_fix
        ),
        is_float_to_float_op(F2FOpStr, F2FOp),
        add_nyi_error_info($pred, phase_constraint, SrcPos, F2FOpStr, !Info),
        Z = tfzn_float_term_const(0.0),
        Constraints = no_tfzn_constraints
    ).

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

:- pred translate_float_float_to_float(ilhs::in, src_pos::in,
    float_float_to_float_op::in,
    tfzn_float_term::in, tfzn_float_term::in, tfzn_float_term::out,
    tfzn_constraint_set::out, tr_info::in, tr_info::out) is det.

translate_float_float_to_float(ILHS, SrcPos, FF2FOp, A, B, Z, Constraints,
        !Info) :-
    (
        A = tfzn_float_term_const(FloatA),
        B = tfzn_float_term_const(FloatB),
        % XXX This case should have been handled by the optimization step.
        translate_par_float_par_float_to_float(SrcPos, FF2FOp, FloatA, FloatB,
            FloatZ, [], Specs),
        add_errors(Specs, !Info),
        Z = tfzn_float_term_const(FloatZ),
        Constraints = no_tfzn_constraints
    ;
        A = tfzn_float_term_const(FloatA),
        B = tfzn_float_term_var(FloatVarB),
        translate_par_float_var_float_to_float(ILHS, SrcPos, FF2FOp,
            FloatA, FloatVarB, Z, Constraints, !Info)
    ;
        A = tfzn_float_term_var(FloatVarA),
        B = tfzn_float_term_const(FloatB),
        translate_var_float_par_float_to_float(ILHS, SrcPos, FF2FOp,
            FloatVarA, FloatB, Z, Constraints, !Info)
    ;
        A = tfzn_float_term_var(_FloatVarA),
        B = tfzn_float_term_var(_FloatVarB),
        translate_var_float_var_float_to_float(ILHS, SrcPos, FF2FOp,
            A, B, Z, Constraints, !Info)
    ).

:- pred translate_par_float_par_float_to_float(src_pos::in,
    float_float_to_float_op::in, float::in, float::in, float::out,
    list(error_spec)::in, list(error_spec)::out) is det.

translate_par_float_par_float_to_float(SrcPos, FF2FOp, FloatA, FloatB, FloatZ,
        !Specs) :-
    (
        ( FF2FOp = ff2f_add,      FloatZ = FloatA + FloatB
        ; FF2FOp = ff2f_sub,      FloatZ = FloatA - FloatB
        ; FF2FOp = ff2f_mul,      FloatZ = FloatA * FloatB
        ; FF2FOp = ff2f_min,      FloatZ = float.min(FloatA, FloatB)
        ; FF2FOp = ff2f_max,      FloatZ = float.max(FloatA, FloatB)
        )
    ;
        FF2FOp = ff2f_div,
        ( if FloatB = 0.0 then
            add_user_error($pred, phase_constraint, SrcPos,
                "Division by zero", !Specs),
            FloatZ = 0.0
          else
            FloatZ = FloatA / FloatB
        )
    ;
        FF2FOp = ff2f_pow,
        ( if FloatB < 0.0 then
            add_user_error($pred, phase_constraint, SrcPos,
                "Cannot raise integer to a negative power", !Specs),
            FloatZ = 0.0
        else
            FloatZ = math.pow(FloatA, FloatB)
        )
    ;
        FF2FOp = ff2f_log,
        ( if FloatA =< 0.0 then
            add_user_error($pred, phase_constraint, SrcPos,
                "log/2 with negative or zero base", !Specs),
            FloatZ = 0.0
        else if FloatA = 1.0 then
            add_user_error($pred, phase_constraint, SrcPos,
                "log/2 with base equal to 1", !Specs),
            FloatZ = 0.0
        else
            compare(Result, FloatB, 0.0),
            (
                Result = (<),
                add_user_error($pred, phase_constraint, SrcPos,
                    "Cannot take the logarithm of a negative number", !Specs),
                FloatZ = 0.0
            ;
                Result = (=),
                add_user_error($pred, phase_constraint, SrcPos,
                    "Cannot take the logarithm of zero", !Specs),
                FloatZ = 0.0
            ;
                Result = (>),
                FloatZ = math.log(FloatA, FloatB)
            )
        )
    ).

:- pred translate_par_float_var_float_to_float(ilhs::in, src_pos::in,
    float_float_to_float_op::in, float::in, tfzn_float_var::in,
    tfzn_float_term::out, tfzn_constraint_set::out,
    tr_info::in, tr_info::out) is det.

translate_par_float_var_float_to_float(ILHS, SrcPos, FF2FOp,
        FloatA, FloatVarB, Z, Constraints, !Info) :-
    (
        FF2FOp = ff2f_mul,
        ( if FloatA = 0.0 then
            Z = tfzn_float_term_const(0.0),
            Constraints = no_tfzn_constraints
        else if FloatA = 1.0 then
            Z = tfzn_float_term_var(FloatVarB),
            Constraints = no_tfzn_constraints
        else
            A = tfzn_float_term_const(FloatA),
            B = tfzn_float_term_var(FloatVarB),
            translate_var_float_var_float_to_float(ILHS, SrcPos, FF2FOp,
                A, B, Z, Constraints, !Info)
        )
    ;
        ( FF2FOp = ff2f_add
        ; FF2FOp = ff2f_sub
        ; FF2FOp = ff2f_min
        ; FF2FOp = ff2f_max
        ; FF2FOp = ff2f_div
        ; FF2FOp = ff2f_pow
        ; FF2FOp = ff2f_log
        ),
        A = tfzn_float_term_const(FloatA),
        B = tfzn_float_term_var(FloatVarB),
        translate_var_float_var_float_to_float(ILHS, SrcPos, FF2FOp,
            A, B, Z, Constraints, !Info)
    ).

:- pred translate_var_float_par_float_to_float(ilhs::in, src_pos::in,
    float_float_to_float_op::in, tfzn_float_var::in, float::in,
    tfzn_float_term::out, tfzn_constraint_set::out,
    tr_info::in, tr_info::out) is det.

translate_var_float_par_float_to_float(ILHS, SrcPos, FF2FOp,
        FloatVarA, FloatB, Z, Constraints, !Info) :-
    (
        FF2FOp = ff2f_mul,
        ( if FloatB = 0.0 then
            Z = tfzn_float_term_const(0.0),
            Constraints = no_tfzn_constraints
        else if FloatB = 1.0 then
            Z = tfzn_float_term_var(FloatVarA),
            Constraints = no_tfzn_constraints
        else
            A = tfzn_float_term_var(FloatVarA),
            B = tfzn_float_term_const(FloatB),
            translate_var_float_var_float_to_float(ILHS, SrcPos, FF2FOp,
                A, B, Z, Constraints, !Info)
        )
    ;
        ( FF2FOp = ff2f_add
        ; FF2FOp = ff2f_sub
        ; FF2FOp = ff2f_min
        ; FF2FOp = ff2f_max
        ; FF2FOp = ff2f_div
        ; FF2FOp = ff2f_pow
        ; FF2FOp = ff2f_log
        ),
        A = tfzn_float_term_var(FloatVarA),
        B = tfzn_float_term_const(FloatB),
        translate_var_float_var_float_to_float(ILHS, SrcPos, FF2FOp,
            A, B, Z, Constraints, !Info)
    ).

:- pred translate_var_float_var_float_to_float(ilhs::in, src_pos::in,
    float_float_to_float_op::in, tfzn_float_term::in, tfzn_float_term::in,
    tfzn_float_term::out, tfzn_constraint_set::out,
    tr_info::in, tr_info::out) is det.

translate_var_float_var_float_to_float(_ILHS, SrcPos, FF2FOp, A, B, Z,
        Constraints, !Info) :-
    (
        ( FF2FOp = ff2f_add, TFznOp = float_plus
        ; FF2FOp = ff2f_sub, TFznOp = float_minus
        ; FF2FOp = ff2f_mul, TFznOp = float_times
        ; FF2FOp = ff2f_min, TFznOp = float_min
        ; FF2FOp = ff2f_max, TFznOp = float_max
        ),
        tr_info_get_cse_maps(!.Info, CSEMaps0),
        get_cse_map_ff2f(CSEMaps0, FF2FMap0),
        ( if map.search(FF2FMap0, {TFznOp, A, B}, CSEResult) then
            % XXX Can we tighten the bounds on FloatVarZ?
            CSEResult = {FloatVarZ, ConstraintItem},
            Z = tfzn_float_term_var(FloatVarZ)
        else
            float_bounds_range(LBA, UBA) = find_float_term_bounds(!.Info, A),
            float_bounds_range(LBB, UBB) = find_float_term_bounds(!.Info, B),
            (
                FF2FOp = ff2f_add,
                float_plus_bounds(LBA, UBA, LBB, UBB, LBZ, UBZ)
            ;
                FF2FOp = ff2f_sub,
                float_times_bounds(-1.0, -1.0, LBB, UBB, LBMB, UBMB),
                float_plus_bounds(LBA, UBA, LBMB, UBMB, LBZ, UBZ)
            ;
                FF2FOp = ff2f_mul,
                float_times_bounds(LBA, UBA, LBB, UBB, LBZ, UBZ)
            ;
                FF2FOp = ff2f_min,
                float_min_bounds(LBA, UBA, LBB, UBB, LBZ, UBZ)
            ;
                FF2FOp = ff2f_max,
                float_max_bounds(LBA, UBA, LBB, UBB, LBZ, UBZ)
            ),
            FloatBoundsZ = float_bounds_range(LBZ, UBZ),
            % XXX If we have FloatExprA and FloatExprB, can we use them
            % to set MaybeFloatExprZ?
            MaybeFloatBoundsZ = no,
            FloatVarInfoZ = var_info_float(var_is_var, var_is_not_output,
                FloatBoundsZ, MaybeFloatBoundsZ),
            add_tmp_var_float(FloatVarInfoZ, FloatVarZ, !Info),

            % XXX Should we make the constraint half-reified if ILHS is
            % ilhs_var(BoolVar)? (If we do, we cannot add to CSEMaps0.)
            % If BoolVar = false, then we may not have to compute Z,
            % but testing BoolVar can be more expensive than computing Z.
            Z = tfzn_float_term_var(FloatVarZ),
            Constraint = tfzn_constr_float_arith_binop(TFznOp, A, B, Z),
            Ann = constr_ann_defines_var(tfzn_def_float_var(FloatVarZ)),
            Anns = set.make_singleton_set(Ann),
            ConstraintItem = tfzn_item_constraint(Constraint, Anns),

            map.det_insert({TFznOp, A, B}, {FloatVarZ, ConstraintItem},
                FF2FMap0, FF2FMap),
            set_cse_map_ff2f(FF2FMap, CSEMaps0, CSEMaps),
            tr_info_set_cse_maps(CSEMaps, !Info)
        ),
        Constraints = one_tfzn_constraint(ConstraintItem)
    ;
        FF2FOp = ff2f_div,
        add_nyi_error_info($pred, phase_constraint, SrcPos, "ff2f_div", !Info),
        Z = tfzn_float_term_const(0.0),
        Constraints = no_tfzn_constraints
    ;
        FF2FOp = ff2f_pow,
        % XXX flatten.float.m does not implement this either.
        add_nyi_error_info($pred, phase_constraint, SrcPos, "ff2f_pow", !Info),
        Z = tfzn_float_term_const(0.0),
        Constraints = no_tfzn_constraints
    ;
        FF2FOp = ff2f_log,
        % XXX flatten.float.m does not implement this either.
        add_nyi_error_info($pred, phase_constraint, SrcPos, "ff2f_log", !Info),
        Z = tfzn_float_term_const(0.0),
        Constraints = no_tfzn_constraints
    ).

%-----------------------------------------------------------------------------%
:- end_module translate.float.
%-----------------------------------------------------------------------------%
